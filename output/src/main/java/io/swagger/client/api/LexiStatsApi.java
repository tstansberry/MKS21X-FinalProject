/**
 * 
 * No descripton provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.11.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import io.swagger.client.model.NgramsResult;
import io.swagger.client.model.StatsWordResult;
import io.swagger.client.model.StatsWordResultList;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LexiStatsApi {
    private ApiClient apiClient;

    public LexiStatsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public LexiStatsApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /* Build call for statsFrequencyNgramsSourceLangCorpusNgramSizeGet */
    private com.squareup.okhttp.Call statsFrequencyNgramsSourceLangCorpusNgramSizeGetCall(String sourceLang, String corpus, String ngramSize, String appId, String appKey, String tokens, String contains, String punctuation, String format, Long minFrequency, Long maxFrequency, Long minDocumentFrequency, Long maxDocumentFrequency, String collate, String sort, Long offset, Long limit, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sourceLang' is set
        if (sourceLang == null) {
            throw new ApiException("Missing the required parameter 'sourceLang' when calling statsFrequencyNgramsSourceLangCorpusNgramSizeGet(Async)");
        }
        
        // verify the required parameter 'corpus' is set
        if (corpus == null) {
            throw new ApiException("Missing the required parameter 'corpus' when calling statsFrequencyNgramsSourceLangCorpusNgramSizeGet(Async)");
        }
        
        // verify the required parameter 'ngramSize' is set
        if (ngramSize == null) {
            throw new ApiException("Missing the required parameter 'ngramSize' when calling statsFrequencyNgramsSourceLangCorpusNgramSizeGet(Async)");
        }
        
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling statsFrequencyNgramsSourceLangCorpusNgramSizeGet(Async)");
        }
        
        // verify the required parameter 'appKey' is set
        if (appKey == null) {
            throw new ApiException("Missing the required parameter 'appKey' when calling statsFrequencyNgramsSourceLangCorpusNgramSizeGet(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stats/frequency/ngrams/{source_lang}/{corpus}/{ngram-size}/".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "source_lang" + "\\}", apiClient.escapeString(sourceLang.toString()))
        .replaceAll("\\{" + "corpus" + "\\}", apiClient.escapeString(corpus.toString()))
        .replaceAll("\\{" + "ngram-size" + "\\}", apiClient.escapeString(ngramSize.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (tokens != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "tokens", tokens));
        if (contains != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "contains", contains));
        if (punctuation != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "punctuation", punctuation));
        if (format != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "format", format));
        if (minFrequency != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "minFrequency", minFrequency));
        if (maxFrequency != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxFrequency", maxFrequency));
        if (minDocumentFrequency != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "minDocumentFrequency", minDocumentFrequency));
        if (maxDocumentFrequency != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxDocumentFrequency", maxDocumentFrequency));
        if (collate != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "collate", collate));
        if (sort != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sort", sort));
        if (offset != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "offset", offset));
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "limit", limit));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (appId != null)
        localVarHeaderParams.put("app_id", apiClient.parameterToString(appId));
        if (appKey != null)
        localVarHeaderParams.put("app_key", apiClient.parameterToString(appKey));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Retrieve the frequency of ngrams (1-4) derived from a corpus
     * This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size &#x3D; 1) or words (ngram size &gt; 1) appear in the corpus. Ngrams are case sensitive (\&quot;I AM\&quot; and \&quot;I am\&quot; will have different frequency) and frequencies are calculated per word (true case) so \&quot;the book\&quot; and \&quot;the books\&quot; are two different ngrams. The results can be filtered based on query parameters. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). &lt;br&gt; &lt;br&gt; Example for bigrams (ngram of size 2): * PATH: /tokens&#x3D;a word,another word * GET: /?tokens&#x3D;a word&amp;tokens&#x3D;another word * POST (json):    &#x60;&#x60;&#x60;javascript     {         \&quot;tokens\&quot;: [\&quot;a word\&quot;, \&quot;another word\&quot;]     }   &#x60;&#x60;&#x60;  Either \&quot;tokens\&quot; or \&quot;contains\&quot; has to be provided. &lt;br&gt; &lt;br&gt; Some queries with \&quot;contains\&quot; or \&quot;sort\&quot; can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \&quot;minFrequency\&quot; and \&quot;maxFrequency\&quot;. &lt;br&gt; &lt;br&gt; You can use the parameters \&quot;offset\&quot; and \&quot;limit\&quot; to paginate through large result sets. For convenience, the HTTP header \&quot;Link\&quot; is set on the response to provide links to \&quot;first\&quot;, \&quot;self\&quot;, \&quot;next\&quot;, \&quot;prev\&quot; and \&quot;last\&quot; pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \&quot;limit\&quot; is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. &lt;br&gt; &lt;br&gt; Some libraries such as python&#39;s &#x60;requests&#x60; can parse the header automatically and offer a convenient way of iterating through the results. For example: &#x60;&#x60;&#x60;python def get_all_results(url):     while url:         r &#x3D; requests.get(url)         r.raise_for_status()         for item in r.json()[&#39;results&#39;]:           yield item         url &#x3D; r.links.get(&#39;next&#39;, {}).get(&#39;url&#39;) &#x60;&#x60;&#x60; 
     * @param sourceLang IANA language code (required)
     * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (required)
     * @param ngramSize the size of ngrams requested (1-4) (required)
     * @param appId App ID Authentication Parameter (required)
     * @param appKey App Key Authentication Parameter (required)
     * @param tokens List of tokens to filter. The tokens are separated by spaces, the list items are separated by comma (e.g., for bigrams (n&#x3D;2) tokens&#x3D;this is,this was, this will) (optional, default to a word)
     * @param contains Find ngrams containing the given token(s). Use comma or space as token separators; the order of tokens is irrelevant. (optional)
     * @param punctuation Flag specifying whether to lookup ngrams that include punctuation or not (possible values are \&quot;true\&quot; and \&quot;false\&quot;; default is \&quot;false\&quot;) (optional)
     * @param format Option specifying whether tokens should be returned as a single string (option \&quot;google\&quot;) or as a list of strings (option \&quot;oup\&quot;) (optional, default to oup)
     * @param minFrequency Restrict the query to entries with frequency of at least &#x60;minFrequency&#x60; (optional)
     * @param maxFrequency Restrict the query to entries with frequency of at most &#x60;maxFrequency&#x60; (optional)
     * @param minDocumentFrequency Restrict the query to entries that appear in at least &#x60;minDocumentFrequency&#x60; documents (optional)
     * @param maxDocumentFrequency Restrict the query to entries that appera in at most &#x60;maxDocumentFrequency&#x60; documents (optional)
     * @param collate collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate&#x3D;trueCase,lemma,lexicalCategory). (optional)
     * @param sort sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (&#39;-&#39;). Multiple values can be separated by commas (e.g., sort&#x3D;lexicalCategory,-frequency) (optional)
     * @param offset pagination - results offset (optional, default to 0)
     * @param limit pagination - results limit (optional, default to 100)
     * @return NgramsResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public NgramsResult statsFrequencyNgramsSourceLangCorpusNgramSizeGet(String sourceLang, String corpus, String ngramSize, String appId, String appKey, String tokens, String contains, String punctuation, String format, Long minFrequency, Long maxFrequency, Long minDocumentFrequency, Long maxDocumentFrequency, String collate, String sort, Long offset, Long limit) throws ApiException {
        ApiResponse<NgramsResult> resp = statsFrequencyNgramsSourceLangCorpusNgramSizeGetWithHttpInfo(sourceLang, corpus, ngramSize, appId, appKey, tokens, contains, punctuation, format, minFrequency, maxFrequency, minDocumentFrequency, maxDocumentFrequency, collate, sort, offset, limit);
        return resp.getData();
    }

    /**
     * Retrieve the frequency of ngrams (1-4) derived from a corpus
     * This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size &#x3D; 1) or words (ngram size &gt; 1) appear in the corpus. Ngrams are case sensitive (\&quot;I AM\&quot; and \&quot;I am\&quot; will have different frequency) and frequencies are calculated per word (true case) so \&quot;the book\&quot; and \&quot;the books\&quot; are two different ngrams. The results can be filtered based on query parameters. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). &lt;br&gt; &lt;br&gt; Example for bigrams (ngram of size 2): * PATH: /tokens&#x3D;a word,another word * GET: /?tokens&#x3D;a word&amp;tokens&#x3D;another word * POST (json):    &#x60;&#x60;&#x60;javascript     {         \&quot;tokens\&quot;: [\&quot;a word\&quot;, \&quot;another word\&quot;]     }   &#x60;&#x60;&#x60;  Either \&quot;tokens\&quot; or \&quot;contains\&quot; has to be provided. &lt;br&gt; &lt;br&gt; Some queries with \&quot;contains\&quot; or \&quot;sort\&quot; can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \&quot;minFrequency\&quot; and \&quot;maxFrequency\&quot;. &lt;br&gt; &lt;br&gt; You can use the parameters \&quot;offset\&quot; and \&quot;limit\&quot; to paginate through large result sets. For convenience, the HTTP header \&quot;Link\&quot; is set on the response to provide links to \&quot;first\&quot;, \&quot;self\&quot;, \&quot;next\&quot;, \&quot;prev\&quot; and \&quot;last\&quot; pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \&quot;limit\&quot; is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. &lt;br&gt; &lt;br&gt; Some libraries such as python&#39;s &#x60;requests&#x60; can parse the header automatically and offer a convenient way of iterating through the results. For example: &#x60;&#x60;&#x60;python def get_all_results(url):     while url:         r &#x3D; requests.get(url)         r.raise_for_status()         for item in r.json()[&#39;results&#39;]:           yield item         url &#x3D; r.links.get(&#39;next&#39;, {}).get(&#39;url&#39;) &#x60;&#x60;&#x60; 
     * @param sourceLang IANA language code (required)
     * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (required)
     * @param ngramSize the size of ngrams requested (1-4) (required)
     * @param appId App ID Authentication Parameter (required)
     * @param appKey App Key Authentication Parameter (required)
     * @param tokens List of tokens to filter. The tokens are separated by spaces, the list items are separated by comma (e.g., for bigrams (n&#x3D;2) tokens&#x3D;this is,this was, this will) (optional, default to a word)
     * @param contains Find ngrams containing the given token(s). Use comma or space as token separators; the order of tokens is irrelevant. (optional)
     * @param punctuation Flag specifying whether to lookup ngrams that include punctuation or not (possible values are \&quot;true\&quot; and \&quot;false\&quot;; default is \&quot;false\&quot;) (optional)
     * @param format Option specifying whether tokens should be returned as a single string (option \&quot;google\&quot;) or as a list of strings (option \&quot;oup\&quot;) (optional, default to oup)
     * @param minFrequency Restrict the query to entries with frequency of at least &#x60;minFrequency&#x60; (optional)
     * @param maxFrequency Restrict the query to entries with frequency of at most &#x60;maxFrequency&#x60; (optional)
     * @param minDocumentFrequency Restrict the query to entries that appear in at least &#x60;minDocumentFrequency&#x60; documents (optional)
     * @param maxDocumentFrequency Restrict the query to entries that appera in at most &#x60;maxDocumentFrequency&#x60; documents (optional)
     * @param collate collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate&#x3D;trueCase,lemma,lexicalCategory). (optional)
     * @param sort sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (&#39;-&#39;). Multiple values can be separated by commas (e.g., sort&#x3D;lexicalCategory,-frequency) (optional)
     * @param offset pagination - results offset (optional, default to 0)
     * @param limit pagination - results limit (optional, default to 100)
     * @return ApiResponse&lt;NgramsResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<NgramsResult> statsFrequencyNgramsSourceLangCorpusNgramSizeGetWithHttpInfo(String sourceLang, String corpus, String ngramSize, String appId, String appKey, String tokens, String contains, String punctuation, String format, Long minFrequency, Long maxFrequency, Long minDocumentFrequency, Long maxDocumentFrequency, String collate, String sort, Long offset, Long limit) throws ApiException {
        com.squareup.okhttp.Call call = statsFrequencyNgramsSourceLangCorpusNgramSizeGetCall(sourceLang, corpus, ngramSize, appId, appKey, tokens, contains, punctuation, format, minFrequency, maxFrequency, minDocumentFrequency, maxDocumentFrequency, collate, sort, offset, limit, null, null);
        Type localVarReturnType = new TypeToken<NgramsResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve the frequency of ngrams (1-4) derived from a corpus (asynchronously)
     * This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size &#x3D; 1) or words (ngram size &gt; 1) appear in the corpus. Ngrams are case sensitive (\&quot;I AM\&quot; and \&quot;I am\&quot; will have different frequency) and frequencies are calculated per word (true case) so \&quot;the book\&quot; and \&quot;the books\&quot; are two different ngrams. The results can be filtered based on query parameters. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). &lt;br&gt; &lt;br&gt; Example for bigrams (ngram of size 2): * PATH: /tokens&#x3D;a word,another word * GET: /?tokens&#x3D;a word&amp;tokens&#x3D;another word * POST (json):    &#x60;&#x60;&#x60;javascript     {         \&quot;tokens\&quot;: [\&quot;a word\&quot;, \&quot;another word\&quot;]     }   &#x60;&#x60;&#x60;  Either \&quot;tokens\&quot; or \&quot;contains\&quot; has to be provided. &lt;br&gt; &lt;br&gt; Some queries with \&quot;contains\&quot; or \&quot;sort\&quot; can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \&quot;minFrequency\&quot; and \&quot;maxFrequency\&quot;. &lt;br&gt; &lt;br&gt; You can use the parameters \&quot;offset\&quot; and \&quot;limit\&quot; to paginate through large result sets. For convenience, the HTTP header \&quot;Link\&quot; is set on the response to provide links to \&quot;first\&quot;, \&quot;self\&quot;, \&quot;next\&quot;, \&quot;prev\&quot; and \&quot;last\&quot; pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \&quot;limit\&quot; is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. &lt;br&gt; &lt;br&gt; Some libraries such as python&#39;s &#x60;requests&#x60; can parse the header automatically and offer a convenient way of iterating through the results. For example: &#x60;&#x60;&#x60;python def get_all_results(url):     while url:         r &#x3D; requests.get(url)         r.raise_for_status()         for item in r.json()[&#39;results&#39;]:           yield item         url &#x3D; r.links.get(&#39;next&#39;, {}).get(&#39;url&#39;) &#x60;&#x60;&#x60; 
     * @param sourceLang IANA language code (required)
     * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (required)
     * @param ngramSize the size of ngrams requested (1-4) (required)
     * @param appId App ID Authentication Parameter (required)
     * @param appKey App Key Authentication Parameter (required)
     * @param tokens List of tokens to filter. The tokens are separated by spaces, the list items are separated by comma (e.g., for bigrams (n&#x3D;2) tokens&#x3D;this is,this was, this will) (optional, default to a word)
     * @param contains Find ngrams containing the given token(s). Use comma or space as token separators; the order of tokens is irrelevant. (optional)
     * @param punctuation Flag specifying whether to lookup ngrams that include punctuation or not (possible values are \&quot;true\&quot; and \&quot;false\&quot;; default is \&quot;false\&quot;) (optional)
     * @param format Option specifying whether tokens should be returned as a single string (option \&quot;google\&quot;) or as a list of strings (option \&quot;oup\&quot;) (optional, default to oup)
     * @param minFrequency Restrict the query to entries with frequency of at least &#x60;minFrequency&#x60; (optional)
     * @param maxFrequency Restrict the query to entries with frequency of at most &#x60;maxFrequency&#x60; (optional)
     * @param minDocumentFrequency Restrict the query to entries that appear in at least &#x60;minDocumentFrequency&#x60; documents (optional)
     * @param maxDocumentFrequency Restrict the query to entries that appera in at most &#x60;maxDocumentFrequency&#x60; documents (optional)
     * @param collate collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate&#x3D;trueCase,lemma,lexicalCategory). (optional)
     * @param sort sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (&#39;-&#39;). Multiple values can be separated by commas (e.g., sort&#x3D;lexicalCategory,-frequency) (optional)
     * @param offset pagination - results offset (optional, default to 0)
     * @param limit pagination - results limit (optional, default to 100)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call statsFrequencyNgramsSourceLangCorpusNgramSizeGetAsync(String sourceLang, String corpus, String ngramSize, String appId, String appKey, String tokens, String contains, String punctuation, String format, Long minFrequency, Long maxFrequency, Long minDocumentFrequency, Long maxDocumentFrequency, String collate, String sort, Long offset, Long limit, final ApiCallback<NgramsResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = statsFrequencyNgramsSourceLangCorpusNgramSizeGetCall(sourceLang, corpus, ngramSize, appId, appKey, tokens, contains, punctuation, format, minFrequency, maxFrequency, minDocumentFrequency, maxDocumentFrequency, collate, sort, offset, limit, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<NgramsResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for statsFrequencyWordSourceLangGet */
    private com.squareup.okhttp.Call statsFrequencyWordSourceLangGetCall(String sourceLang, String appId, String appKey, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sourceLang' is set
        if (sourceLang == null) {
            throw new ApiException("Missing the required parameter 'sourceLang' when calling statsFrequencyWordSourceLangGet(Async)");
        }
        
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling statsFrequencyWordSourceLangGet(Async)");
        }
        
        // verify the required parameter 'appKey' is set
        if (appKey == null) {
            throw new ApiException("Missing the required parameter 'appKey' when calling statsFrequencyWordSourceLangGet(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stats/frequency/word/{source_lang}/".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "source_lang" + "\\}", apiClient.escapeString(sourceLang.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (corpus != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "corpus", corpus));
        if (wordform != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "wordform", wordform));
        if (trueCase != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "trueCase", trueCase));
        if (lemma != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "lemma", lemma));
        if (lexicalCategory != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "lexicalCategory", lexicalCategory));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (appId != null)
        localVarHeaderParams.put("app_id", apiClient.parameterToString(appId));
        if (appKey != null)
        localVarHeaderParams.put("app_key", apiClient.parameterToString(appKey));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Retrieve the frequency of a word derived from a corpus.
     * This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma&#x3D;test, the returned frequency will include the verb \&quot;test\&quot;, the noun \&quot;test\&quot; and the adjective \&quot;test\&quot; in all forms (Test, tested, testing, etc.) &lt;br&gt; &lt;br&gt; If you are interested in the frequency of the word \&quot;test\&quot; but want to exclude other forms (e.g., tested) use the option trueCase&#x3D;test. Normally, the word \&quot;test\&quot; will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count \&quot;Test\&quot; and \&quot;test\&quot; as the same token. If you are interested in frequencies of \&quot;Test\&quot; and \&quot;test\&quot;, use the option wordform&#x3D;test or wordform&#x3D;Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word \&quot;press\&quot; in Oxford University Press. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples: * PATH: /lemma&#x3D;test;lexicalCategory&#x3D;noun * GET: /?lemma&#x3D;test&amp;lexicalCategory&#x3D;noun * POST (json):    &#x60;&#x60;&#x60;javascript     {       \&quot;lemma\&quot;: \&quot;test\&quot;,       \&quot;lexicalCategory\&quot;: \&quot;noun\&quot;     }   &#x60;&#x60;&#x60;  &lt;br&gt; One of the options wordform/trueCase/lemma/lexicalCategory has to be provided. 
     * @param sourceLang IANA language code (required)
     * @param appId App ID Authentication Parameter (required)
     * @param appKey App Key Authentication Parameter (required)
     * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (optional, default to nmc)
     * @param wordform The written form of the word to look up (preserving case e.g., Books vs books) (optional)
     * @param trueCase The written form of the word to look up with normalised case (Books --&gt; books) (optional)
     * @param lemma The lemma of the word to look up (e.g., Book, booked, books all have the lemma \&quot;book\&quot;) (optional, default to test)
     * @param lexicalCategory The lexical category of the word(s) to look up (e.g., noun or verb) (optional)
     * @return StatsWordResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StatsWordResult statsFrequencyWordSourceLangGet(String sourceLang, String appId, String appKey, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory) throws ApiException {
        ApiResponse<StatsWordResult> resp = statsFrequencyWordSourceLangGetWithHttpInfo(sourceLang, appId, appKey, corpus, wordform, trueCase, lemma, lexicalCategory);
        return resp.getData();
    }

    /**
     * Retrieve the frequency of a word derived from a corpus.
     * This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma&#x3D;test, the returned frequency will include the verb \&quot;test\&quot;, the noun \&quot;test\&quot; and the adjective \&quot;test\&quot; in all forms (Test, tested, testing, etc.) &lt;br&gt; &lt;br&gt; If you are interested in the frequency of the word \&quot;test\&quot; but want to exclude other forms (e.g., tested) use the option trueCase&#x3D;test. Normally, the word \&quot;test\&quot; will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count \&quot;Test\&quot; and \&quot;test\&quot; as the same token. If you are interested in frequencies of \&quot;Test\&quot; and \&quot;test\&quot;, use the option wordform&#x3D;test or wordform&#x3D;Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word \&quot;press\&quot; in Oxford University Press. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples: * PATH: /lemma&#x3D;test;lexicalCategory&#x3D;noun * GET: /?lemma&#x3D;test&amp;lexicalCategory&#x3D;noun * POST (json):    &#x60;&#x60;&#x60;javascript     {       \&quot;lemma\&quot;: \&quot;test\&quot;,       \&quot;lexicalCategory\&quot;: \&quot;noun\&quot;     }   &#x60;&#x60;&#x60;  &lt;br&gt; One of the options wordform/trueCase/lemma/lexicalCategory has to be provided. 
     * @param sourceLang IANA language code (required)
     * @param appId App ID Authentication Parameter (required)
     * @param appKey App Key Authentication Parameter (required)
     * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (optional, default to nmc)
     * @param wordform The written form of the word to look up (preserving case e.g., Books vs books) (optional)
     * @param trueCase The written form of the word to look up with normalised case (Books --&gt; books) (optional)
     * @param lemma The lemma of the word to look up (e.g., Book, booked, books all have the lemma \&quot;book\&quot;) (optional, default to test)
     * @param lexicalCategory The lexical category of the word(s) to look up (e.g., noun or verb) (optional)
     * @return ApiResponse&lt;StatsWordResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StatsWordResult> statsFrequencyWordSourceLangGetWithHttpInfo(String sourceLang, String appId, String appKey, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory) throws ApiException {
        com.squareup.okhttp.Call call = statsFrequencyWordSourceLangGetCall(sourceLang, appId, appKey, corpus, wordform, trueCase, lemma, lexicalCategory, null, null);
        Type localVarReturnType = new TypeToken<StatsWordResult>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve the frequency of a word derived from a corpus. (asynchronously)
     * This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma&#x3D;test, the returned frequency will include the verb \&quot;test\&quot;, the noun \&quot;test\&quot; and the adjective \&quot;test\&quot; in all forms (Test, tested, testing, etc.) &lt;br&gt; &lt;br&gt; If you are interested in the frequency of the word \&quot;test\&quot; but want to exclude other forms (e.g., tested) use the option trueCase&#x3D;test. Normally, the word \&quot;test\&quot; will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count \&quot;Test\&quot; and \&quot;test\&quot; as the same token. If you are interested in frequencies of \&quot;Test\&quot; and \&quot;test\&quot;, use the option wordform&#x3D;test or wordform&#x3D;Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word \&quot;press\&quot; in Oxford University Press. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples: * PATH: /lemma&#x3D;test;lexicalCategory&#x3D;noun * GET: /?lemma&#x3D;test&amp;lexicalCategory&#x3D;noun * POST (json):    &#x60;&#x60;&#x60;javascript     {       \&quot;lemma\&quot;: \&quot;test\&quot;,       \&quot;lexicalCategory\&quot;: \&quot;noun\&quot;     }   &#x60;&#x60;&#x60;  &lt;br&gt; One of the options wordform/trueCase/lemma/lexicalCategory has to be provided. 
     * @param sourceLang IANA language code (required)
     * @param appId App ID Authentication Parameter (required)
     * @param appKey App Key Authentication Parameter (required)
     * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (optional, default to nmc)
     * @param wordform The written form of the word to look up (preserving case e.g., Books vs books) (optional)
     * @param trueCase The written form of the word to look up with normalised case (Books --&gt; books) (optional)
     * @param lemma The lemma of the word to look up (e.g., Book, booked, books all have the lemma \&quot;book\&quot;) (optional, default to test)
     * @param lexicalCategory The lexical category of the word(s) to look up (e.g., noun or verb) (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call statsFrequencyWordSourceLangGetAsync(String sourceLang, String appId, String appKey, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, final ApiCallback<StatsWordResult> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = statsFrequencyWordSourceLangGetCall(sourceLang, appId, appKey, corpus, wordform, trueCase, lemma, lexicalCategory, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StatsWordResult>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for statsFrequencyWordsSourceLangGet */
    private com.squareup.okhttp.Call statsFrequencyWordsSourceLangGetCall(String sourceLang, String appId, String appKey, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, String grammaticalFeatures, String sort, String collate, Long minFrequency, Long maxFrequency, Float minNormalizedFrequency, Float maxNormalizedFrequency, Long offset, Long limit, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sourceLang' is set
        if (sourceLang == null) {
            throw new ApiException("Missing the required parameter 'sourceLang' when calling statsFrequencyWordsSourceLangGet(Async)");
        }
        
        // verify the required parameter 'appId' is set
        if (appId == null) {
            throw new ApiException("Missing the required parameter 'appId' when calling statsFrequencyWordsSourceLangGet(Async)");
        }
        
        // verify the required parameter 'appKey' is set
        if (appKey == null) {
            throw new ApiException("Missing the required parameter 'appKey' when calling statsFrequencyWordsSourceLangGet(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stats/frequency/words/{source_lang}/".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "source_lang" + "\\}", apiClient.escapeString(sourceLang.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (corpus != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "corpus", corpus));
        if (wordform != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "wordform", wordform));
        if (trueCase != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "trueCase", trueCase));
        if (lemma != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "lemma", lemma));
        if (lexicalCategory != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "lexicalCategory", lexicalCategory));
        if (grammaticalFeatures != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "grammaticalFeatures", grammaticalFeatures));
        if (sort != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sort", sort));
        if (collate != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "collate", collate));
        if (minFrequency != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "minFrequency", minFrequency));
        if (maxFrequency != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxFrequency", maxFrequency));
        if (minNormalizedFrequency != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "minNormalizedFrequency", minNormalizedFrequency));
        if (maxNormalizedFrequency != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxNormalizedFrequency", maxNormalizedFrequency));
        if (offset != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "offset", offset));
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "limit", limit));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (appId != null)
        localVarHeaderParams.put("app_id", apiClient.parameterToString(appId));
        if (appKey != null)
        localVarHeaderParams.put("app_key", apiClient.parameterToString(appKey));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Retrieve a list of frequencies of a word/words derived from a corpus.
     * This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. &lt;br&gt; &lt;br&gt; To exclude a specific value, prepend it with the minus sign (&#39;-&#39;). For example, to get frequencies of the lemma &#39;happy&#39; but exclude superlative forms (i.e., happiest) you could use options &#39;lemma&#x3D;happy;grammaticalFeatures&#x3D;-degreeType:superlative&#39;. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). &lt;br&gt; &lt;br&gt; The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples: * PATH: /wordforms&#x3D;happy,happier,happiest * GET: /?wordforms&#x3D;happy&amp;wordforms&#x3D;happier&amp;wordforms&#x3D;happiest * POST (json): &#x60;&#x60;&#x60;javascript   {     \&quot;wordforms\&quot;: [\&quot;happy\&quot;, \&quot;happier\&quot;, \&quot;happiest\&quot;]   } &#x60;&#x60;&#x60; A mor complex example of retrieving frequencies of multiple lemmas: &#x60;&#x60;&#x60;   {       \&quot;lemmas\&quot;: [\&quot;happy\&quot;, \&quot;content\&quot;, \&quot;cheerful\&quot;, \&quot;cheery\&quot;, \&quot;merry\&quot;, \&quot;joyful\&quot;, \&quot;ecstatic\&quot;],       \&quot;grammaticalFeatures\&quot;: {           \&quot;adjectiveFunctionType\&quot;: \&quot;predicative\&quot;       },       \&quot;lexicalCategory\&quot;: \&quot;adjective\&quot;,       \&quot;sort\&quot;: [\&quot;lemma\&quot;, \&quot;-frequency\&quot;]   } &#x60;&#x60;&#x60; Some queries with \&quot;collate\&quot; or \&quot;sort\&quot; can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \&quot;minFrequency\&quot; and \&quot;maxFrequency\&quot;. &lt;br&gt; &lt;br&gt; You can use the parameters \&quot;offset\&quot; and \&quot;limit\&quot; to paginate through large result sets. For convenience, the HTTP header \&quot;Link\&quot; is set on the response to provide links to \&quot;first\&quot;, \&quot;self\&quot;, \&quot;next\&quot;, \&quot;prev\&quot; and \&quot;last\&quot; pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \&quot;limit\&quot; is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. &lt;br&gt; &lt;br&gt; Some libraries such as python&#39;s &#x60;requests&#x60; can parse the header automatically and offer a convenient way of iterating through the results. For example: &#x60;&#x60;&#x60;python def get_all_results(url):     while url:         r &#x3D; requests.get(url)         r.raise_for_status()         for item in r.json()[&#39;results&#39;]:           yield item         url &#x3D; r.links.get(&#39;next&#39;, {}).get(&#39;url&#39;) &#x60;&#x60;&#x60; 
     * @param sourceLang IANA language code (required)
     * @param appId App ID Authentication Parameter (required)
     * @param appKey App Key Authentication Parameter (required)
     * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (optional, default to nmc)
     * @param wordform The written form of the word to look up (preserving case e.g., Book vs book) (optional)
     * @param trueCase The written form of the word to look up with normalised case (Books --&gt; books) (optional)
     * @param lemma The lemma of the word to look up (e.g., Book, booked, books all have the lemma \&quot;book\&quot;) (optional, default to test)
     * @param lexicalCategory The lexical category of the word(s) to look up (e.g., adjective or noun) (optional)
     * @param grammaticalFeatures The grammatical features of the word(s) to look up entered as a list of k:v (e.g., degree_type:comparative) (optional)
     * @param sort sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (&#39;-&#39;). Multiple values can be separated by commas (e.g., sort&#x3D;lexicalCategory,-frequency) (optional)
     * @param collate collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate&#x3D;trueCase,lemma,lexicalCategory). (optional)
     * @param minFrequency Restrict the query to entries with frequency of at least &#x60;minFrequency&#x60; (optional)
     * @param maxFrequency Restrict the query to entries with frequency of at most &#x60;maxFrequency&#x60; (optional)
     * @param minNormalizedFrequency Restrict the query to entries with frequency of at least &#x60;minNormalizedFrequency&#x60; (optional)
     * @param maxNormalizedFrequency Restrict the query to entries with frequency of at most &#x60;maxNormalizedFrequency&#x60; (optional)
     * @param offset pagination - results offset (optional, default to 0)
     * @param limit pagination - results limit (optional, default to 100)
     * @return StatsWordResultList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StatsWordResultList statsFrequencyWordsSourceLangGet(String sourceLang, String appId, String appKey, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, String grammaticalFeatures, String sort, String collate, Long minFrequency, Long maxFrequency, Float minNormalizedFrequency, Float maxNormalizedFrequency, Long offset, Long limit) throws ApiException {
        ApiResponse<StatsWordResultList> resp = statsFrequencyWordsSourceLangGetWithHttpInfo(sourceLang, appId, appKey, corpus, wordform, trueCase, lemma, lexicalCategory, grammaticalFeatures, sort, collate, minFrequency, maxFrequency, minNormalizedFrequency, maxNormalizedFrequency, offset, limit);
        return resp.getData();
    }

    /**
     * Retrieve a list of frequencies of a word/words derived from a corpus.
     * This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. &lt;br&gt; &lt;br&gt; To exclude a specific value, prepend it with the minus sign (&#39;-&#39;). For example, to get frequencies of the lemma &#39;happy&#39; but exclude superlative forms (i.e., happiest) you could use options &#39;lemma&#x3D;happy;grammaticalFeatures&#x3D;-degreeType:superlative&#39;. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). &lt;br&gt; &lt;br&gt; The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples: * PATH: /wordforms&#x3D;happy,happier,happiest * GET: /?wordforms&#x3D;happy&amp;wordforms&#x3D;happier&amp;wordforms&#x3D;happiest * POST (json): &#x60;&#x60;&#x60;javascript   {     \&quot;wordforms\&quot;: [\&quot;happy\&quot;, \&quot;happier\&quot;, \&quot;happiest\&quot;]   } &#x60;&#x60;&#x60; A mor complex example of retrieving frequencies of multiple lemmas: &#x60;&#x60;&#x60;   {       \&quot;lemmas\&quot;: [\&quot;happy\&quot;, \&quot;content\&quot;, \&quot;cheerful\&quot;, \&quot;cheery\&quot;, \&quot;merry\&quot;, \&quot;joyful\&quot;, \&quot;ecstatic\&quot;],       \&quot;grammaticalFeatures\&quot;: {           \&quot;adjectiveFunctionType\&quot;: \&quot;predicative\&quot;       },       \&quot;lexicalCategory\&quot;: \&quot;adjective\&quot;,       \&quot;sort\&quot;: [\&quot;lemma\&quot;, \&quot;-frequency\&quot;]   } &#x60;&#x60;&#x60; Some queries with \&quot;collate\&quot; or \&quot;sort\&quot; can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \&quot;minFrequency\&quot; and \&quot;maxFrequency\&quot;. &lt;br&gt; &lt;br&gt; You can use the parameters \&quot;offset\&quot; and \&quot;limit\&quot; to paginate through large result sets. For convenience, the HTTP header \&quot;Link\&quot; is set on the response to provide links to \&quot;first\&quot;, \&quot;self\&quot;, \&quot;next\&quot;, \&quot;prev\&quot; and \&quot;last\&quot; pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \&quot;limit\&quot; is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. &lt;br&gt; &lt;br&gt; Some libraries such as python&#39;s &#x60;requests&#x60; can parse the header automatically and offer a convenient way of iterating through the results. For example: &#x60;&#x60;&#x60;python def get_all_results(url):     while url:         r &#x3D; requests.get(url)         r.raise_for_status()         for item in r.json()[&#39;results&#39;]:           yield item         url &#x3D; r.links.get(&#39;next&#39;, {}).get(&#39;url&#39;) &#x60;&#x60;&#x60; 
     * @param sourceLang IANA language code (required)
     * @param appId App ID Authentication Parameter (required)
     * @param appKey App Key Authentication Parameter (required)
     * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (optional, default to nmc)
     * @param wordform The written form of the word to look up (preserving case e.g., Book vs book) (optional)
     * @param trueCase The written form of the word to look up with normalised case (Books --&gt; books) (optional)
     * @param lemma The lemma of the word to look up (e.g., Book, booked, books all have the lemma \&quot;book\&quot;) (optional, default to test)
     * @param lexicalCategory The lexical category of the word(s) to look up (e.g., adjective or noun) (optional)
     * @param grammaticalFeatures The grammatical features of the word(s) to look up entered as a list of k:v (e.g., degree_type:comparative) (optional)
     * @param sort sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (&#39;-&#39;). Multiple values can be separated by commas (e.g., sort&#x3D;lexicalCategory,-frequency) (optional)
     * @param collate collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate&#x3D;trueCase,lemma,lexicalCategory). (optional)
     * @param minFrequency Restrict the query to entries with frequency of at least &#x60;minFrequency&#x60; (optional)
     * @param maxFrequency Restrict the query to entries with frequency of at most &#x60;maxFrequency&#x60; (optional)
     * @param minNormalizedFrequency Restrict the query to entries with frequency of at least &#x60;minNormalizedFrequency&#x60; (optional)
     * @param maxNormalizedFrequency Restrict the query to entries with frequency of at most &#x60;maxNormalizedFrequency&#x60; (optional)
     * @param offset pagination - results offset (optional, default to 0)
     * @param limit pagination - results limit (optional, default to 100)
     * @return ApiResponse&lt;StatsWordResultList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StatsWordResultList> statsFrequencyWordsSourceLangGetWithHttpInfo(String sourceLang, String appId, String appKey, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, String grammaticalFeatures, String sort, String collate, Long minFrequency, Long maxFrequency, Float minNormalizedFrequency, Float maxNormalizedFrequency, Long offset, Long limit) throws ApiException {
        com.squareup.okhttp.Call call = statsFrequencyWordsSourceLangGetCall(sourceLang, appId, appKey, corpus, wordform, trueCase, lemma, lexicalCategory, grammaticalFeatures, sort, collate, minFrequency, maxFrequency, minNormalizedFrequency, maxNormalizedFrequency, offset, limit, null, null);
        Type localVarReturnType = new TypeToken<StatsWordResultList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Retrieve a list of frequencies of a word/words derived from a corpus. (asynchronously)
     * This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. &lt;br&gt; &lt;br&gt; To exclude a specific value, prepend it with the minus sign (&#39;-&#39;). For example, to get frequencies of the lemma &#39;happy&#39; but exclude superlative forms (i.e., happiest) you could use options &#39;lemma&#x3D;happy;grammaticalFeatures&#x3D;-degreeType:superlative&#39;. &lt;br&gt; &lt;br&gt; Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). &lt;br&gt; &lt;br&gt; The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples: * PATH: /wordforms&#x3D;happy,happier,happiest * GET: /?wordforms&#x3D;happy&amp;wordforms&#x3D;happier&amp;wordforms&#x3D;happiest * POST (json): &#x60;&#x60;&#x60;javascript   {     \&quot;wordforms\&quot;: [\&quot;happy\&quot;, \&quot;happier\&quot;, \&quot;happiest\&quot;]   } &#x60;&#x60;&#x60; A mor complex example of retrieving frequencies of multiple lemmas: &#x60;&#x60;&#x60;   {       \&quot;lemmas\&quot;: [\&quot;happy\&quot;, \&quot;content\&quot;, \&quot;cheerful\&quot;, \&quot;cheery\&quot;, \&quot;merry\&quot;, \&quot;joyful\&quot;, \&quot;ecstatic\&quot;],       \&quot;grammaticalFeatures\&quot;: {           \&quot;adjectiveFunctionType\&quot;: \&quot;predicative\&quot;       },       \&quot;lexicalCategory\&quot;: \&quot;adjective\&quot;,       \&quot;sort\&quot;: [\&quot;lemma\&quot;, \&quot;-frequency\&quot;]   } &#x60;&#x60;&#x60; Some queries with \&quot;collate\&quot; or \&quot;sort\&quot; can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as \&quot;minFrequency\&quot; and \&quot;maxFrequency\&quot;. &lt;br&gt; &lt;br&gt; You can use the parameters \&quot;offset\&quot; and \&quot;limit\&quot; to paginate through large result sets. For convenience, the HTTP header \&quot;Link\&quot; is set on the response to provide links to \&quot;first\&quot;, \&quot;self\&quot;, \&quot;next\&quot;, \&quot;prev\&quot; and \&quot;last\&quot; pages of results (depending on the context). For example, if the result set contains 50 results and the parameter \&quot;limit\&quot; is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. &lt;br&gt; &lt;br&gt; Some libraries such as python&#39;s &#x60;requests&#x60; can parse the header automatically and offer a convenient way of iterating through the results. For example: &#x60;&#x60;&#x60;python def get_all_results(url):     while url:         r &#x3D; requests.get(url)         r.raise_for_status()         for item in r.json()[&#39;results&#39;]:           yield item         url &#x3D; r.links.get(&#39;next&#39;, {}).get(&#39;url&#39;) &#x60;&#x60;&#x60; 
     * @param sourceLang IANA language code (required)
     * @param appId App ID Authentication Parameter (required)
     * @param appKey App Key Authentication Parameter (required)
     * @param corpus For corpora other than &#39;nmc&#39; (New Monitor Corpus) please contact api@oxforddictionaries.com (optional, default to nmc)
     * @param wordform The written form of the word to look up (preserving case e.g., Book vs book) (optional)
     * @param trueCase The written form of the word to look up with normalised case (Books --&gt; books) (optional)
     * @param lemma The lemma of the word to look up (e.g., Book, booked, books all have the lemma \&quot;book\&quot;) (optional, default to test)
     * @param lexicalCategory The lexical category of the word(s) to look up (e.g., adjective or noun) (optional)
     * @param grammaticalFeatures The grammatical features of the word(s) to look up entered as a list of k:v (e.g., degree_type:comparative) (optional)
     * @param sort sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign (&#39;-&#39;). Multiple values can be separated by commas (e.g., sort&#x3D;lexicalCategory,-frequency) (optional)
     * @param collate collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate&#x3D;trueCase,lemma,lexicalCategory). (optional)
     * @param minFrequency Restrict the query to entries with frequency of at least &#x60;minFrequency&#x60; (optional)
     * @param maxFrequency Restrict the query to entries with frequency of at most &#x60;maxFrequency&#x60; (optional)
     * @param minNormalizedFrequency Restrict the query to entries with frequency of at least &#x60;minNormalizedFrequency&#x60; (optional)
     * @param maxNormalizedFrequency Restrict the query to entries with frequency of at most &#x60;maxNormalizedFrequency&#x60; (optional)
     * @param offset pagination - results offset (optional, default to 0)
     * @param limit pagination - results limit (optional, default to 100)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call statsFrequencyWordsSourceLangGetAsync(String sourceLang, String appId, String appKey, String corpus, String wordform, String trueCase, String lemma, String lexicalCategory, String grammaticalFeatures, String sort, String collate, Long minFrequency, Long maxFrequency, Float minNormalizedFrequency, Float maxNormalizedFrequency, Long offset, Long limit, final ApiCallback<StatsWordResultList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = statsFrequencyWordsSourceLangGetCall(sourceLang, appId, appKey, corpus, wordform, trueCase, lemma, lexicalCategory, grammaticalFeatures, sort, collate, minFrequency, maxFrequency, minNormalizedFrequency, maxNormalizedFrequency, offset, limit, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StatsWordResultList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
